def getVersionFile() {
    // Previously we were referencing the versions file using the path from rootDir of the root
    // project, however, now we've introduced more root projects and using the root dir is no longer
    // feasible. Therefore, using a project relative path here. Project relative path will resolve
    // the file path relative to the root of the project that is using the path (as opposed to the
    // root of the root project from where the build was triggered).
    //
    // This version file is located in the common module in the common repo i.e it is located in
    // {repo_root_dir}/common
    //
    // This same version file is being used by four modules:
    // - common, keyvault, labapi, testutils, uiautomationutilities
    //
    // When using the project (module) reference for the version file, gradle will try to resolve
    // the path based on the module that was being built. For instance, when building common it
    // would resolve it as "{repo_root_dir}/common/versioning/version.properties"
    //
    // However, when building keyvault it would resolve it as
    // "{repo_root_dir}/keyvault/versioning/version.properties"
    // but that path is wrong...because the file is located at
    // "{repo_root_dir}/common/versioning/version.properties"
    // and as said above, the same file from common module is used across common, keyvault, labapi,
    // testutils, uiautomationutilities
    // This was probably done to version the LATEST (0.0.+) versions with the same logic.
    // So to get the right path here, we're goind to do a String replace and replace the module name
    // occuring in the path, always with common because that's where the version file is located.
    String path = file("versioning/version.properties").getAbsolutePath()
    final actualPath = path
            .replaceAll("keyvault", "common")
            .replaceAll("labapi", "common")
            .replaceAll("testutils", "common")
            .replaceAll("uiautomationutilities", "common")
    return file(actualPath)
}

def getVersionProps() {
    def versionProps = new Properties();
    getVersionFile().withInputStream { stream -> versionProps.load(stream) }
    return versionProps
}

private String getVersionNamePatch() {
    return (getVersionProps()['versionName'] =~ /[^.]+/)[2].toString()
}

private Integer getVersionNameMinor() {
    return (getVersionProps()['versionName'] =~ /\d+/)[1].toInteger()
}

private Integer getVersionNameMajor() {
    return (getVersionProps()['versionName'] =~ /\d+/)[0].toInteger()
}

private Integer getLatestPatchVersion() {
    return getVersionProps()['latestPatchVersion'].toInteger()
}

ext.getAppVersionCode = {
    getVersionProps()['versionCode'].toInteger()
}

ext.getAppVersionName = {
    getVersionProps()['versionName'].toString()
}

private void saveChanges(String versionName) {
    def versionProps = getVersionProps()
    versionProps['versionName'] = versionName
    versionProps.store(getVersionFile().newWriter(), null)
}

private void incrementLatestVersion() {
    def versionProps = getVersionProps()
    versionProps["latestPatchVersion"] = (getLatestPatchVersion() + 1).toString()
    versionProps.store(getVersionFile().newWriter(), null)
}

task incrementLatestVersionNumber() {
    doLast {
        incrementLatestVersion()
    }
}

task versionSnapshot {
    doLast {
        def versionNameMajor = getVersionNameMajor()
        def versionNameMinor = getVersionNameMinor()
        def versionNamePatch = getVersionNamePatch()
        def versionName = "${versionNameMajor}.${versionNameMinor}.${versionNamePatch}-SNAPSHOT".toString()
        saveChanges(versionName)
    }
}

task versionLatest {
    doLast {
        def versionNameMajor = '0'
        def versionNameMinor = '0'
        def versionNamePatch = getLatestPatchVersion()
        def versionName = "${versionNameMajor}.${versionNameMinor}.${versionNamePatch}".toString()
        saveChanges(versionName)
    }
}
